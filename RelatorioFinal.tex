%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modelo de relatório de Disciplina de MLP a partir da
% classe latex iiufrgs disponivel em http://github.com/schnorr/iiufrgs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%C
% Definição do tipo / classe de documento e estilo usado
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\documentclass[rel_mlp]{iiufrgs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Importação de pacotes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (a A seguir podem ser importados os pacotes necessários para o documento, de acordo 
% com a necessidade)
%
\usepackage[brazilian]{babel}	    % para texto escrito em pt-br
\usepackage[utf8]{inputenc}         % pacote para acentuação
\usepackage{graphicx}         	    % pacote para importar figuras
\usepackage[T1]{fontenc}            % pacote para conj. de caracteres correto
\usepackage{times}                  % pacote para usar fonte Adobe Times
\usepackage{enumerate}              % para lista de itens com letras
\usepackage{breakcites}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{titletoc}               
\usepackage{listings}			    % para listagens de código-fonte
\usepackage{mathptmx}               % p/ usar fonte Adobe Times nas formulas matematicas
\usepackage{url}                    % para formatar URLs
\usepackage[backend=bibtex]{biblatex}%\usepackage{color}				    % para imagens e outras coisas coloridas
\usepackage[pdftex]{hyperref}
\usepackage[colorlinks]{hyperref}
\hypersetup{urlcolor=blue}
\usepackage{cleveref}
%\usepackage{fixltx2e}              % para subscript
%\usepackage{amsmath}               % para \epsilon e matemática
%\usepackage{amsfonts}
%\usepackage{setspace}			    % para mudar espaçamento dos parágrafos
%\usepackage[table,xcdraw]{xcolor}  % para tabelas coloridas
%\usepackage{longtable}             % para tabelas compridas (mais de uma página)
%\usepackage{float}
%\usepackage{booktabs}
%\usepackage{tabularx}
%\usepackage[breaklinks]{hyperref}

\usepackage[alf,abnt-emphasize=bf]{abntex2cite}	% pacote para usar citações abnt

\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}

\usepackage{listings}
\lstset{language=[Sharp]C,
captionpos=b,
%numbers=left, %Nummerierung
%numberstyle=\tiny, % kleine Zeilennummern
frame=lines, % Oberhalb und unterhalb des Listings ist eine Linie
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Macros, ajustes e definições
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%

% define estilo de parágrafo para citação longa direta:
\newenvironment{citacao}{
    %\singlespacing
    %\footnotesize
    \small
    \begin{list}{}{
        \setlength{\leftmargin}{4.0cm}
        \setstretch{1}
        \setlength{\topsep}{1.2cm}
        \setlength{\listparindent}{\parindent}
    }
    \item[]}{\end{list}
}

% adiciona a fonte em figuras e tabelas
\newcommand{\fonte}[1]{\\Fonte: {#1}}

% Ative o seguinte caso alguma nota de rodapé fique muito longa e quebre entre múltiplas
% páginas
%\interfootnotelinepenalty=10000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Informações gerais                                   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% título
\title{%
  Relatório Parcial - Trabalho Final de MLP \\
  \large Tower Defense em C\# - Fullbar}

% autor
\author{Freitas}{Pietra} % {sobrenome}{nome} 1 para cada aluno
\author{Minuzzo}{Thayná} % {sobrenome}{nome} 1 para cada aluno


% Professor orientador da disciplina
\advisor[Prof.~Dr.]{Mello Schnorr}{Lucas}

% Nome do(s) curso(s):
\course{Curso de Graduação em Ciência da Computa{\c{c}}{\~a}o e Engenharia de Computação}

% local da realização do trabalho 
\location{Porto Alegre}{RS} 

% data da entrega do trabalho (mês e ano)
\date{12}{2017}


% Palavras chave
\keyword{MLP}
\keyword{TowerDefense}
\keyword{C\#}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Início do documento e elementos pré-textuais
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Declara início do documento
\begin{document}

% inclui folha de rosto 
\maketitle      

\selectlanguage{brazilian}

% Sumario

\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aqui comeca o texto propriamente dito
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%espaçamento entre parágrafos
%\setlength{\parskip}{6 pt}

\selectlanguage{brazilian}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introdução
%
\chapter{Introdução} \label{intro}

O objetivo deste trabalho consiste na exploração dos paradigmas orientado a objetos e funcional dado um problema e uma linguagem, escolhidos dentre os sugeridos pelo professor, a fim de comparar as características e funcionalidades de tal linguagem de programação em tais paradigmas. 

\section{Introdução ao problema}

Tem-se como problema base a ser abordado, a implementação de um jogo do tipo Tower Defense através dos conhecimentos sobre paradigmas obtidos ao longo do semestre. A ideia básica é executar a defesa de algum elemento presente na tela, fazendo uso de recursos contidos no jogo, que auxiliem nesse trabalho.  

\section{Introdução à linguagem}

Para a abordagem do problema, foi escolhida a linguagem de programação C\#, que possui múltiplos paradigmas de programação. Serão utilizados os paradigmas de orientação a objetos e funcional, presentes na referida linguagem, juntamente com \textit{frameworks} suportados por ela para auxílio da implementação do problema.

\section{Introdução ao \textit{framework} Monogame}

Para o desenvolvimento do trabalho, utilizamos o \textit{framework}, para desenvolvimento de jogos, Monogame - uma implementação \textit{open-source} do \textit{framework} XNA. Com ele, é possível desenvolver jogos em C\# com maior facilidade.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capítulo 2
%
\chapter{Visão Geral da Linguagem}

\section{Apresentação da linguagem escolhida}

A linguagem escolhida, C\#, é uma linguagem influenciada por diversas outras linguagens, como C++ e JAVA. Contudo, durante sua criação, o objetivo consistia em unir os benefícios oferecidos por outras linguagens. É possível observar isso analisando, por exemplo, sua sintaxe, que é muito similar à sintaxe da linguagem C++ e, portanto, uma sintaxe simples e de fácil aprendizagem. 

Além disso, é uma linguagem fortemente tipada e apresenta recursos significativos como tipos de valor nulo, enumerações, delegações, expressões lambdas, acesso direto à memória e suporte a métodos e tipos genéricos. Por ser uma linguagem orientada a objetos, é possível utilizar os recursos associados a esse paradigma, como encapsulamento, herança e polimorfismo. 

Nesse sentido, uma de suas aplicações está no \textit{framework} .NET, em que foi utilizada na maioria das classes. Também possui grande aplicação na engine de games Unity. O trabalho desenvolvido no paradigma OO utiliza o \textit{framework} \textit{Monogame}, portanto, mais uma aplicação de C\#.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capítulo 3
%
\chapter{Análise Crítica}

\section{Critérios e Propriedades}

\subsection{Tabela de Critérios e Propriedades}

    \begin{tabular}{l*{6}{c}r}
    Critério ou Propriedade & Nota \\
		\hline
		Simplicidade & 9 \\ 
		Ortogonalidade & 6 \\
		Expressividade & 9 \\
		Adequabilidade e Variedade de Estruturas de Controle & 9 \\
		Mecanismos de Definição de Tipos & 8 \\
		Suporte a Abstração de Dados e de Processos & 9 \\
		Modelo de Tipos & 7 \\
		Portabilidade & 8 \\
		Reusabilidade & 8 \\
		Suporte à Documentação & 10 \\
		Tamanho do Código & 8 \\
		Generalidade & 8 \\
		Eficiência e Custo & 7
    \end{tabular}

\subsection{Simplicidade}

A linguagem adotada tem um bom potencial quando o quesito avaliado é 	a simplicidade de código, pois é possível fazer uso de 	representações precisas, sem ambiguidades. Isso está relacionado também com o fator de ortogonalidade, que é pouco presente, mas que quando se encontra com frequência em uma determinada linguagem pode gerar tais ambiguidades. De fato, C\# se caracteriza como uma linguagem que possui poucas exceções às regras de construção sintática. Semanticamente, foi implementada uma classe de constantes, o que torna o código simples de entender independentemente do contexto em que ele se encontra.

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]

class Constants
{
/* ABOUT THE GAME */
static public int MAX_ENEMIES = 3;


/* ABOUT THE ENEMIES */
static public int ENEMY_SPAWN_TIME = 4;
static public int ENEMY_START_HEALTH = 100;
static public float ENEMY_SPEED = 1f;

\end{lstlisting}

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]

protected void LoadEnemies()
{
if (spawn >= Constants.ENEMY_SPAWN_TIME) // Respawns an enemy each ENEMY_SPAWN_TIME
{
spawn = 0;
if (enemies.Count <= Constants.MAX_ENEMIES) // Limits the respawn
{
Enemy enemy = new Enemy(enemyTextures[random.Next(0, enemyTextures.Count)], Vector2.Zero);
enemy.SetWaypoints(map.GetWaypoints());

enemies.Add(enemy);

\end{lstlisting}

\subsection{Ortogonalidade}

Existem divergências acerca da questão ortogonalidade para a linguagem escolhida. Por um lado, ela se torna ortogonal por não apresentar exceções no escopo que define seu sistema de tipos. Por outro, ortogonalidade significa apresentar atribuições por intermédio de diferentes tipos de combinações possíveis e ainda gerar resultados coerentes. Seguindo esse segundo princípio, a ortogonalidade de C# é fraca, principalmente pelo fato de ser fortemente tipada. 

\subsection{Expressividade}

A linguagem possui diversas instruções que tornam mais expressivas a escrita dos comandos, através da definição de operadores que abrangem uma grande quantidade de computação.Temos como exemplo os operadores ++ ou - - , que substituem o uso de x = x + 1, por exemplo, garantindo a expressividade. O uso de estruturas de controle que permitem uma fácil expressão do que se quer representar, como o foreach, também são considerados pontos positivos em relação à expressividade do código. Seguem abaixo exemplos de ambas implementações.

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]

 protected void UpdateEnemies(GameTime gameTime)
        {
            foreach (Enemy enemy in enemies)
                enemy.Update(gameTime);

        }

for (int i = 0; i < enemies.Count; i++)
            {
                if (enemies[i].GetOutOfScreen()) // Removes enemies out of screen
                {
                    enemies.RemoveAt(i);
                    i--;
	     ...

\end{lstlisting}

\subsection{Adequabilidade e variedade de estruturas de controle}

A linguagem escolhida se mostra bastante completa quando o quesito é estruturas de controle. Durante a codificação, exploramos isso através de sub-rotinas, estruturas sequenciais, estruturas de seleção e estruturas de repetição, conforme a necessidade e demanda do domínio do problema. Segue um exemplo do uso de sub-rotinas.

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]
protected override void Update(GameTime gameTime)
      	  {
           	 spawn += (float)gameTime.ElapsedGameTime.TotalSeconds;
           	 KeyboardHandler();

           	 UpdateEnemies(gameTime);

           	 LoadEnemies();

           	 player.Update(gameTime, enemies);

		base.Update(gameTime);
       	 }
\end{lstlisting}

\subsection{Mecanismos de definição de tipos}

Por utilizar o paradigma OO, C\# tem a possibilidade da criação de classes. Além disso, é possível criar structs. Portanto, é uma linguagem que conta com mecanismos de definição de tipo.

\subsection{Suporte a abstração de dados e de processos}

Por se tratar de uma linguagem orientada a objetos, ela oferece mecanismos básicos para tal, como herança, encapsulamento, e polimorfismo. A respeito da abstração de processos, observa-se que seu uso se torna algo quase essencial através de subprogramas, para modularização e legibilidade do código como um todo. Ambos os tipos de abstração estão bastante presentes no software desenvolvido, que apresenta onze classes distintas com níveis de herança entre si, todas elas encapsuladas (têm em sua estrutura métodos setters e getters, e seus atributos são protegidos). Os subprogramas existem tanto como métodos de classes, quanto como funções que auxiliam na classe principal. Segue um exemplo que demonstra uma das classes com seu devido encapsulamento, tendo seus atributos protegidos, sendo acessíveis apenas por métodos setters e getters.

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]

namespace MonoGame2D
{
    abstract public class Tower : Sprite
	{
		/* Attributes */
        protected float bulletTimer; // How long ago was a bullet fire
		protected List<Bullet> bulletList = new List<Bullet>();
        protected Enemy target;

        protected int cost; // How much will the tower cost to make
        protected int damage; // The damage done to enemy's
        protected float radius; // How far the tower can shoot
		protected int bulletSpeed;

\end{lstlisting}

\begin{lstlisting}[caption=Trecho de código C\# retirado da implementação deste trabalho, label=lst:test]

/* Getters */
        public int GetCost()
		{
            return cost;
        }

        public int GetDamage()
        {
            return damage;
		}

        public float GetRadius()
        {
			return radius;
		}

		/* Setters */
		public void SetCost(int cost)
		{
            this.cost = cost;
        }

\end{lstlisting}

\subsection{Modelo de tipos}

A linguagem escolhida é fortemente tipada, portanto há checagem de tipo. Contudo, realiza coerção, o que diminui a confiabilidade do código, visto que podem haver coerções não desejadas e não detectadas pelo desenvolvedor à primeira vista.

\subsection{Portabilidade}

Tanto a linguagem quanto o \textit{framework} utilizado, Monogame, podem ser considerados altamente portáveis através de ferramentas específicas. Para portar C\# de forma genérica, usa-se uma implementação do \textit{framework} .NET chamado Mono, que permite desenvolver até mesmo para dispositivos móveis. A respeito do Monogame, a documentação presente o descreve como \textit{plataform-agnostic}. Nossa implementação foi desenvolvida especificamente para o sistema operacional Windows. Mas, através de alguns ajustes, poderia ser utilizada em outras plataformas.

\subsection{Reusabilidade}

É possível implementar códigos tão reusáveis quanto possíveis com a linguagem adotada, pois, além de ser orientada a objetos - o que permite reaproveitamento de código -, ela apresenta uma série de ferramentas para garantir modularidade, como por exemplo, delegates, templates, parametrização. O TowerDefense Game utiliza algumas dessas ferramentas, como, por exemplo, delegates. O reuso é implementado também em escopos menores, com os subprogramas para evitar repetições de código.  

\subsection{Suporte e Documentação}

É possível encontrar a documentação da linguagem no site da Microsoft. Portanto, tem documentação de fácil acesso.

\subsection{Tamanho de Código}

Por ser bastante reutilizável, é possível implementar lógicas com certa complexidade, em C\#, com poucas linhas de código. 

\subsection{Generalidade}

C\# apresenta mecanismos para a definição de estruturas de dados genéricas, portanto é uma linguagem genérica.

\begin{lstlisting}[caption=Trecho de código C\# retirado de documentação online da linguagem, label=lst:test]

public class Stack<T>
{
   readonly int m_Size; 
   int m_StackPointer = 0;
   T[] m_Items;
   public Stack():this(100)
   {}
   public Stack(int size)
   {
      m_Size = size;
      m_Items = new T[m_Size];
   }
   public void Push(T item)
   {
      if(m_StackPointer >= m_Size) 
         throw new StackOverflowException();
      m_Items[m_StackPointer] = item;
      m_StackPointer++;
   }
   public T Pop()
   {
      m_StackPointer--;
      if(m_StackPointer >= 0)
      {
         return m_Items[m_StackPointer];
      }
      else
      {
         m_StackPointer = 0;
         throw new InvalidOperationException("Cannot pop an empty stack");
      }
   }
}

\end{lstlisting}

\subsection{Eficiência e Custo}

A eficiência da linguagem está fortemente relacionada com a implementação da linguagem, que no nosso caso, se apresenta como híbrida, pois apesar de criar um arquivo com extensão executável, existe a necessidade de uma Maquina Virtual .NET para sua interpretação. Ganha-se assim em portabilidade também, pois o código pode ser exportado para plataformas que possuam a VM instalada. Porém, perde-se em performance para a execução. A linguagem possui um alto nível de abstração, logo o custo associado a treinamentos e desenvolvimento torna-se bastante baixo.

\section{Analisando os paradigmas}

--

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capítulo 4
%
\chapter{Sobre o jogo}

\section{Acesso}

O código encontra-se disponível no GitHub, no repositório: \href{https://github.com/TMinuzzo/TowerDefenseGame/}{TowerDefenseGame}.

\section{Uso de Destrutores}

Para a implementação do código, não foram usados destrutores de classe. Isso se deve parcialmente ao fato da existência de um método próprio do framework Monogame chamada UnloadContent(), que tem como objetivo descarregar todo o conteúdo previamente carregado quando ele deixa de ser usado, ou quando existe a invocação do método em questão. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusões
%
\chapter{CONCLUSÃO}

Durante o desenvolvimento do trabalho, uma das grandes vantagens da linguagem escolhida foi sua semelhança, sintaticamente, com a linguagem C++ e, portanto, com a linguagem C, linguagens com as quais as integrantes já estavam familiarizadas.

Além disso, C\# é uma linguagem com paradigma OO. Portanto, a estruturação do código utilizando os recursos desse paradigma aconteceu naturalmente à medida em que o código era incrementado.

Em relação à linguagem, não houve grandes dificuldades. O maior desafio consistiu na utilização do \textit{framework} Monogame. Entretanto, por efeito da utilização desse \textit{framework}, os laços e atualizações necessárias para o fluxo do jogo tornaram-se significativamente mais fáceis de serem desenvolvidos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Referências 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\chapter{Referências}
%\bibliographystyle{abnt}

\href{https://www.devmedia.com.br/introducao-a-linguagem-c/27711}{Devmedia - Introdução à linguagem C\#}

\href{https://pt.wikipedia.org/wiki/Microsoft_XNA}{PT Wikipedia - Microsoft XNA}

\href{https://www.caelum.com.br/apostila-csharp-orientacao-objetos/o-que-e-c-e-net/#2-1-um-pouco-sobre-a-historia-do-c-e-net}{Caelum - O que é C\# e .NET}

\href{https://www.youtube.com/playlist?list=PLV27bZtgVIJqoeHrQq6Mt_S1-Fvq_zzGZ}{Oyyou - Monogame Tutorials}

\href{http://www.monogame.net/documentation/?page=main}{Monogame - Documentation}

\href{http://rbwhitaker.wikidot.com/monogame-tutorials}{Rikidot - Monogame Tutorials}

\href{https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/}{Microsoft - C\# / Programming Guide}

\href{https://docs.microsoft.com/en-us/dotnet/csharp/}{Microsoft - C\# / Documentation}

\href{https://sophia.javeriana.edu.co/~cbustaca/docencia/POO-2016-01/documentos/Object%20Oriented%20Software%20Construction-Meyer.pdf}{Sophia Javeriana - Object Oriented Software Construction - Meyer}

%\nocite{*}
%\bibliographystyle{abntex2-alf}
%\bibliography{biblio} % arquivo que contém as referências (no formato bib). Colocar as suas lá (se tiver dúvida sobre como adicionar novas referências, usar o software JabRef ou Medley)

\end{document}
